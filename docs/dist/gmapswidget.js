/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/providers/gmaps-widget/GmapsWidget.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@google/markerclusterer/src/markerclusterer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@google/markerclusterer/src/markerclusterer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0.3\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'imagePath': (string) The base URL where the images representing\n *                  clusters will be found. The full URL will be:\n *                  {imagePath}[1-5].{imageExtension}\n *                  Default: '../images/m'.\n *     'imageExtension': (string) The suffix for images URL representing\n *                       clusters will be found. See _imagePath_ for details.\n *                       Default: 'png'.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    // Determines map type and prevent illegal zoom levels\n    var zoom = that.map_.getZoom();\n    var minZoom = that.map_.minZoom || 0;\n    var maxZoom = Math.min(that.map_.maxZoom || 100,\n                         that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);\n    zoom = Math.min(Math.max(zoom,minZoom),maxZoom);\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  if (markers.length) {\n    for (var i = 0, marker; marker = markers[i]; i++) {\n      this.pushMarkerTo_(marker);\n    }\n  } else if (Object.keys(markers).length) {\n    for (var marker in markers) {\n      this.pushMarkerTo_(markers[marker]);\n    }\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  // create a local copy of markers if required\n  // (removeMarker_ modifies the getMarkers() array in place)\n  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;\n  var removed = false;\n\n  for (var i = 0, marker; marker = markersCopy[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the number of markers in the cluster.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns a list of the markers in the cluster.\n *\n * @return {Array.<google.maps.Marker>} The markers in the cluster.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer.map_, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n    this.div_.style.zIndex = google.maps.Marker.MAX_ZINDEX + 1;\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nvar window = window || {};\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\nObject.keys = Object.keys || function(o) {\n    var result = [];\n    for(var name in o) {\n        if (o.hasOwnProperty(name))\n          result.push(name);\n    }\n    return result;\n};\n\nif (true) {\n  module.exports = MarkerClusterer;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@google/markerclusterer/src/markerclusterer.js?");

/***/ }),

/***/ "./node_modules/asap/browser-raw.js":
/*!******************************************!*\
  !*** ./node_modules/asap/browser-raw.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/asap/browser-raw.js?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/style.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/style.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\nexports.push([module.i, \"/* Loader */\\n@keyframes scaleout {\\n    0% {\\n        transform: scale(0.0);\\n    } 100% {\\n          transform: scale(1.0);\\n          opacity: 0;\\n      }\\n}\\n\\n.batmap__spinner {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    content: '';\\n    width: 50px;\\n    height: 50px;\\n    margin: auto;\\n    padding: 50px 0 0 50px;\\n    background-color: #333;\\n\\n    border-radius: 100%;\\n    animation: scaleout 1.0s infinite ease-in-out;\\n}\\n\\n.batmap__map {\\n    position: relative;\\n    z-index: 0;\\n}\\n\\n/* Mappy */\\n.batmap-mappy .mappy-control-zoom a span {\\n    position: relative;\\n    top: -5px;\\n}\\n\\n.batmap-mappy .leaflet-control.leaflet-control-attribution,\\n.batmap-mappy .leaflet-control.leaflet-control-scale {\\n    padding: 0 5px;\\n}\\n\\n/* Leaflet */\\n.batmap-leaflet.leaflet-touch .leaflet-bar a {\\n    line-height: 26px;\\n}\\n\", \"\"]);\n\n//# sourceURL=webpack:///./src/style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction ToObject(val) {\n\tif (val == null) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction ownEnumerableKeys(obj) {\n\tvar keys = Object.getOwnPropertyNames(obj);\n\n\tif (Object.getOwnPropertySymbols) {\n\t\tkeys = keys.concat(Object.getOwnPropertySymbols(obj));\n\t}\n\n\treturn keys.filter(function (key) {\n\t\treturn propIsEnumerable.call(obj, key);\n\t});\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar from;\n\tvar keys;\n\tvar to = ToObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = arguments[s];\n\t\tkeys = ownEnumerableKeys(Object(from));\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tto[keys[i]] = from[keys[i]];\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/promise/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/promise/lib/core.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar asap = __webpack_require__(/*! asap/raw */ \"./node_modules/asap/browser-raw.js\");\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('Promise constructor\\'s argument is not a function');\n  }\n  this._h = 0;\n  this._i = 0;\n  this._j = null;\n  this._k = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._l = null;\nPromise._m = null;\nPromise._n = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n}\nfunction handle(self, deferred) {\n  while (self._i === 3) {\n    self = self._j;\n  }\n  if (Promise._l) {\n    Promise._l(self);\n  }\n  if (self._i === 0) {\n    if (self._h === 0) {\n      self._h = 1;\n      self._k = deferred;\n      return;\n    }\n    if (self._h === 1) {\n      self._h = 2;\n      self._k = [self._k, deferred];\n      return;\n    }\n    self._k.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._i === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._i === 1) {\n        resolve(deferred.promise, self._j);\n      } else {\n        reject(deferred.promise, self._j);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._j);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._i = 3;\n      self._j = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._i = 1;\n  self._j = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._i = 2;\n  self._j = newValue;\n  if (Promise._m) {\n    Promise._m(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._h === 1) {\n    handle(self, self._k);\n    self._k = null;\n  }\n  if (self._h === 2) {\n    for (var i = 0; i < self._k.length; i++) {\n      handle(self, self._k[i]);\n    }\n    self._k = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  });\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/core.js?");

/***/ }),

/***/ "./node_modules/promise/lib/es6-extensions.js":
/*!****************************************************!*\
  !*** ./node_modules/promise/lib/es6-extensions.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._n);\n  p._i = 1;\n  p._j = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._i === 3) {\n            val = val._j;\n          }\n          if (val._i === 1) return res(i, val._j);\n          if (val._i === 2) reject(val._j);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/es6-extensions.js?");

/***/ }),

/***/ "./node_modules/promise/lib/rejection-tracking.js":
/*!********************************************************!*\
  !*** ./node_modules/promise/lib/rejection-tracking.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Promise = __webpack_require__(/*! ./core */ \"./node_modules/promise/lib/core.js\");\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._l = null;\n  Promise._m = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._l = function (promise) {\n    if (\n      promise._i === 2 && // IS REJECTED\n      rejections[promise._o]\n    ) {\n      if (rejections[promise._o].logged) {\n        onHandled(promise._o);\n      } else {\n        clearTimeout(rejections[promise._o].timeout);\n      }\n      delete rejections[promise._o];\n    }\n  };\n  Promise._m = function (promise, err) {\n    if (promise._h === 0) { // not yet handled\n      promise._o = id++;\n      rejections[promise._o] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._o),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/promise/lib/rejection-tracking.js?");

/***/ }),

/***/ "./node_modules/simple-js-validator/lib/simple.js.validator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/simple-js-validator/lib/simple.js.validator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * Simple.Js.Validator v0.12.3\r\n *\r\n * @class Validator\r\n * A collection of simple validations for common actions\r\n *\r\n * @type {SimpleJS.Validator}\r\n */\r\n\r\n(function(exports) {\r\n  \"use strict\";\r\n\r\n  /**\r\n   * Returns ***true*** if the value is empty; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if empty; false if not empty\r\n   */\r\n  var isEmpty = exports.isEmpty = function(value) {\r\n\r\n    if (typeof value === 'undefined') {\r\n      return true;\r\n    } else if (value === null) {\r\n      return true;\r\n    } else if (isNAN(value)) {\r\n      return true;\r\n    } else if (value === '') {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return false;\r\n    } else if (value === false) {\r\n      return false;\r\n    } else if (isDate(value)) {\r\n      // new Date() is an object, but it has no keys/props so it will fail the isObject check\r\n      // so if it is a date, it is considered populated\r\n      // also the for loop with the hasOwnProperty did not pass the new Date() either\r\n      // also the _.isEmpty did not pass the new Date() check\r\n      // ...could use _.isDate, but trying to reduce the dependency on external libs\r\n      return false;\r\n    } else if (isError(value)) {\r\n      // new Error() is an object, but it has no keys/props so it will fail the isObject\r\n      // so if it is an error, it is considered populated\r\n      return false;\r\n    } else if (isEmptyObject(value)) {\r\n      // this did not pass the new Date() check by itself, so added the date check above\r\n      // this did not pass the new Error() check by itself, so added the error check above\r\n      return true;\r\n    } else if (isEmptyArray(value)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is not empty; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if not empty; false if empty\r\n   */\r\n  var isNotEmpty = exports.isNotEmpty = function(value) {\r\n    return !isEmpty(value);\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is defined; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isDefined = exports.isDefined = function(value) {\r\n\r\n    if (typeof value === 'undefined') {\r\n      return false;\r\n    } else if (value === null) {\r\n      return false;\r\n    } else if (isNAN(value)) {\r\n      return false;\r\n    } else if (value === '') {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return true;\r\n    } else if (value === false) {\r\n      return true;\r\n    } else if (isObject(value)) {\r\n      return true;\r\n    } else if (isArray(value)) {\r\n      return true;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is not defined; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if not defined; false if defined\r\n   */\r\n  var isNotDefined = exports.isNotDefined = function(value) {\r\n    return !isDefined(value);\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is true, \"true\", \"T\", or 1; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - true\r\n   *  - \"true\"\r\n   *  - \"T\"\r\n   *  - 1\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isTrue = exports.isTrue = function(value) {\r\n    if (value === true) {\r\n      return true;\r\n    } else if (value === 1) {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" && value.toLowerCase() === \"true\") {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"t\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is false, \"false\", \"f\", or 0; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - true\r\n   *  - 1\r\n   *  - anything else\r\n   *\r\n   *  * Returns ***true*** for the following:\r\n   *\r\n   *  - false\r\n   *  - \"false\"\r\n   *  - \"F\"\r\n   *  - 0\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isFalse = exports.isFalse = function(value) {\r\n    if (value === false) {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"false\") {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"f\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Throws an error if the object is not defined (see {@link #isNotDefined} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsDefined = exports.assertIsDefined = function(toAssertName, toAssertObj){\r\n    if (isNotDefined(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is not defined.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is defined (see {@link #isDefined} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsNotDefined = exports.assertIsNotDefined = function(toAssertName, toAssertObj){\r\n    if (isDefined(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is defined.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is empty (see {@link #isEmpty} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsNotEmpty = exports.assertIsNotEmpty = function(toAssertName, toAssertObj){\r\n    if (isEmpty(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is empty.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is not empty (see {@link #isNotEmpty} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsEmpty = exports.assertIsEmpty = function(toAssertName, toAssertObj){\r\n    if (isNotEmpty(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is not empty.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will throw an error if any input is not defined\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefined = exports.validateFunctionInputsAreDefined = function (fnInputs, inputsToValidate, functionName) {\r\n    return validateInputsAreDefined(fnInputs, inputsToValidate, 'fnInputs', functionName);\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will throw an error if any input is not defined\r\n   *\r\n   * @param {Object} inputs                       object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must be defined in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefined = exports.validateInputsAreDefined = function (inputs, inputsToValidate, inputName, functionName) {\r\n    functionName = functionName + ' validateInputsAreDefined ';\r\n\r\n    if (isEmpty(inputs)) {\r\n      throw new Error(functionName +  inputName + ' must not be empty');\r\n    }\r\n\r\n    if (!isArray(inputsToValidate)) {\r\n      throw new Error(functionName + 'inputsToValidate must be an array');\r\n    }\r\n\r\n    for (var i=0; i<inputsToValidate.length; i++) {\r\n      var input = inputsToValidate[i];\r\n\r\n      var toTest = getPropertyByString(inputs, input);\r\n\r\n      if (isNotDefined(toTest)) {\r\n        throw new Error(functionName + 'following input must be defined: ' + inputName + '.' + input);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefinedAsync = exports.validateFunctionInputsAreDefinedAsync = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreDefined(fnInputs, inputsToValidate, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefinedCallbackOnError = exports.validateFunctionInputsAreDefinedCallbackOnError = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreDefined(fnInputs, inputsToValidate, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefinedAsync = exports.validateInputsAreDefinedAsync = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreDefined(fnInputs, inputsToValidate, inputName, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefinedCallbackOnError = exports.validateInputsAreDefinedCallbackOnError = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreDefined(fnInputs, inputsToValidate, inputName, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will throw an error if any input is empty\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmpty = exports.validateFunctionInputsAreNotEmpty = function (fnInputs, inputsToValidate, functionName) {\r\n    return validateInputsAreNotEmpty(fnInputs, inputsToValidate, 'fnInputs', functionName);\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will throw an error if any input is empty\r\n   *\r\n   * @param {Object} inputs                       object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmpty = exports.validateInputsAreNotEmpty = function (inputs, inputsToValidate, inputName, functionName) {\r\n    functionName = functionName + ' validateInputsAreNotEmpty ';\r\n\r\n    if (isEmpty(inputs)) {\r\n      throw new Error(functionName +  inputName + ' must not be empty');\r\n    }\r\n\r\n    if (!isArray(inputsToValidate)) {\r\n      throw new Error(functionName + 'inputsToValidate must be an array');\r\n    }\r\n\r\n    for (var i=0; i<inputsToValidate.length; i++) {\r\n      var input = inputsToValidate[i];\r\n\r\n      var toTest = getPropertyByString(inputs, input);\r\n\r\n      if (isEmpty(toTest)) {\r\n        throw new Error(functionName + 'following input must not be empty: ' + inputName + '.' + input);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate      a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmptyAsync = exports.validateFunctionInputsAreNotEmptyAsync = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreNotEmpty(fnInputs, inputsToValidate, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate      a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmptyCallbackOnError = exports.validateFunctionInputsAreNotEmptyCallbackOnError = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreNotEmpty(fnInputs, inputsToValidate, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmptyAsync = exports.validateInputsAreNotEmptyAsync = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreNotEmpty(fnInputs, inputsToValidate, inputName, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmptyCallbackOnError = exports.validateInputsAreNotEmptyCallbackOnError = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreNotEmpty(fnInputs, inputsToValidate, inputName, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if array; otherwise, false\r\n   */\r\n  var isArray = exports.isArray = function(obj) {\r\n    if (obj && typeof obj === 'object' && typeof obj.length !== 'undefined' && obj.length >= 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not array; otherwise, false\r\n   */\r\n  var isNotArray = exports.isNotArray = function(obj) {\r\n    return !isArray(obj);\r\n  };\r\n\r\n\r\n  /**\r\n   * Determines if the object is an empty array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if empty array; otherwise, false\r\n   */\r\n  var isEmptyArray = exports.isEmptyArray = function(obj) {\r\n    if (isArray(obj) && typeof obj.length !== 'undefined' && obj.length === 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a populated array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if populated array; otherwise, false\r\n   */\r\n  var isNotEmptyArray = exports.isNotEmptyArray = function(obj) {\r\n    if (isArray(obj) && typeof obj.length !== 'undefined' && obj.length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a NaN or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if NaN; otherwise, false\r\n   */\r\n  var isNAN = exports.isNAN = function(obj) {\r\n    // NaN value check\r\n    // ...and yes you need to check that it is a number before checking that it is NotANumber.  Who knew?\r\n    if (typeof obj === 'number' && isNaN(obj)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a Date or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Date; otherwise, false\r\n   */\r\n  var isDate = exports.isDate = function(obj) {\r\n    // new Date() is an object, but it has no keys/props so it will fail straight isObject check\r\n    // so if it is a date, it is considered populated\r\n    // also the for loop with the hasOwnProperty did not pass the new Date() either\r\n    // also the _.isEmpty did not pass the new Date() check\r\n    // ...could use _.isDate, but trying to reduce the dependency on external libs\r\n    if (typeof obj === 'object' && Object.prototype.toString.call(obj) === \"[object Date]\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not a Date or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Date; otherwise, false\r\n   */\r\n  var isNotDate = exports.isNotDate = function(obj) {\r\n    return !isDate(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an Error or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Error; otherwise, false\r\n   */\r\n  var isError = exports.isError = function(obj) {\r\n    // new Error() is an object, but it has no keys/props so it will fail straight isObject check\r\n    if (typeof obj === 'object' && Object.prototype.toString.call(obj) === \"[object Error]\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an Error or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Error; otherwise, false\r\n   */\r\n  var isNotError = exports.isNotError = function(obj) {\r\n    return !isError(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an Object or not.  Note returns false on new Date() and new Error().\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Object; otherwise, false\r\n   */\r\n  var isObject = exports.isObject = function(obj) {\r\n    // object check\r\n    // this returns false if obj=new Date()\r\n    // this returns false if obj=new Error()\r\n    if (obj && typeof obj === 'object' && isNotArray(obj) && isNotDate(obj) && isNotError(obj)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an Object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Object; otherwise, false\r\n   */\r\n  var isNotObject = exports.isNotObject = function(obj) {\r\n    return !isObject(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an empty object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if empty object; otherwise, false\r\n   */\r\n  var isEmptyObject = exports.isEmptyObject = function(obj) {\r\n    if (isObject(obj) && Object.keys(obj).length === 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a populated object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if populated object; otherwise, false\r\n   */\r\n  var isNotEmptyObject = exports.isNotEmptyObject = function(obj) {\r\n    if (isObject(obj) && Object.keys(obj).length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /*\r\n   * Gets the property based on the string.\r\n   * So if the obj={foo:{bar:{blah:\"here\"}}}, getPropertyByString(obj, \"foo.bar.blah\") would return \"here\"\r\n   * There cannot be any \".\" in any of the property names for this to work correctly\r\n   * see http://stackoverflow.com/questions/6906108/in-javascript-how-can-i-dynamically-get-a-nested-property-of-an-object\r\n   *\r\n   * @param {Object} obj                      object to be search\r\n   * @param {String} propString               name of the property to find; use \".\" to indicate parent/child elements\r\n   * @returns {Object}                        returns the property value\r\n   */\r\n  var getPropertyByString = exports.getPropertyByString = function(obj, propString) {\r\n    if (isEmpty(propString)) {return obj;}\r\n\r\n    var prop;\r\n    var props = propString.split('.');\r\n\r\n    var propLength = props.length - 1;\r\n    var i=0;\r\n    for (i=0; i < propLength; i++) {\r\n      prop = props[i];\r\n\r\n      if (typeof obj === 'object' && obj !== null && prop in obj) {\r\n        obj = obj[prop];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return obj[props[i]];\r\n  };\r\n\r\n  /*\r\n   * Sets the property based on the string.\r\n   * So if the obj={foo:{bar:{blah:\"here\"}}}, setPropertyByString(obj, \"foo.bar.blah\", \"newHere\") would replace \"here\" with \"newHere\"\r\n   * There cannot be any \".\" in any of the property names for this to work correctly\r\n   * see http://stackoverflow.com/questions/6906108/in-javascript-how-can-i-dynamically-get-a-nested-property-of-an-object\r\n   *\r\n   * @param {Object} obj                      object to be search\r\n   * @param {String} propString               name of the property to find; use \".\" to indicate parent/child elements\r\n   * @param {Object} newValue                 the property value to set\r\n   */\r\n  var setPropertyByString =  exports.setPropertyByString = function(obj, propString, newValue) {\r\n    if (isEmpty(propString)) {return obj;}\r\n\r\n    var prop;\r\n    var props = propString.split('.');\r\n\r\n    var propLength = props.length - 1;\r\n\r\n    if (propLength === 0) {\r\n      obj[propString] = newValue;\r\n    } else {\r\n      var lookupObj = obj;\r\n      for (var i=0; i <= propLength - 1; i++) {\r\n        prop = props[i];\r\n\r\n        if (typeof obj === 'object' && obj !== null && prop in obj) {\r\n          obj = obj[prop];\r\n        } else {\r\n          obj[prop] = {};\r\n          obj = obj[prop];\r\n        }\r\n      }\r\n\r\n      // then on last prop in propString\r\n      prop = props[i];\r\n      if (typeof obj === 'object' && obj !== null) {\r\n        obj[prop] = newValue;\r\n      } else {\r\n        // do not update anything since the obj doesn't exist\r\n      }\r\n    }\r\n    return;\r\n  };\r\n\r\n  var assertNestedListIsDefined =  exports.assertNestedListIsDefined = function(list) {\r\n    if (isNotArray(list)) {return false;}\r\n\r\n    list.forEach(function(item) {\r\n      assertNestedIsDefined.apply(null, item);\r\n    });\r\n\r\n    return true;\r\n  };\r\n\r\n  var assertNestedIsDefined =  exports.assertNestedIsDefined = function(obj, toAssertName) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    for (var i = 0; i < args.length; i++) {\r\n      if (!obj) {\r\n        throw new Error(toAssertName + ' is not defined.');\r\n      }\r\n      if (!obj.hasOwnProperty(args[i]) || isNotDefined(obj[args[i]])) {\r\n        throw new Error(toAssertName + '.' + args[i] + ' is not defined.');\r\n      }\r\n      obj = obj[args[i]];\r\n      toAssertName = toAssertName + '.' + args[i];\r\n    }\r\n    return true;\r\n  };\r\n\r\n})( false? undefined: exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/simple-js-validator/lib/simple.js.validator.js?");

/***/ }),

/***/ "./node_modules/style-loader/addStyles.js":
/*!************************************************!*\
  !*** ./node_modules/style-loader/addStyles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/addStyles.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/AbstractMap.js":
/*!****************************!*\
  !*** ./src/AbstractMap.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n__webpack_require__(/*! ./style.css */ \"./src/style.css\");\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar dom = __webpack_require__(/*! ./utils/dom */ \"./src/utils/dom.js\");\n\nif (typeof Promise === 'undefined') {\n  __webpack_require__(/*! promise/lib/rejection-tracking */ \"./node_modules/promise/lib/rejection-tracking.js\").enable();\n\n  window.Promise = __webpack_require__(/*! promise/lib/es6-extensions.js */ \"./node_modules/promise/lib/es6-extensions.js\");\n}\n\nvar AbstractMap =\n/*#__PURE__*/\nfunction () {\n  function AbstractMap(domSelector, apiKey, locale) {\n    var showCluster = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var showLabel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var showPosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    var callback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function () {};\n\n    _classCallCheck(this, AbstractMap);\n\n    this.domElement = dom.isHTMLElement(domSelector) ? domSelector : document.querySelector(domSelector);\n    this.domId = this.domElement.id || '';\n    this.apiKey = apiKey;\n    this.locale = locale || 'en';\n    this.provider = '[No provider defined]';\n    this.showCluster = showCluster;\n    this.showLabel = showLabel;\n    this.showPosition = showPosition;\n    this.map = null;\n    this.points = [];\n    this.markers = [];\n    this.icons = [];\n    this.bounds = null;\n    this.cluster = null;\n    this.defaultOptions = {\n      zoom: 12,\n      locationZoom: 16\n    };\n    this.load(callback);\n  }\n\n  _createClass(AbstractMap, [{\n    key: \"load\",\n    value: function load(callback) {\n      callback();\n    }\n  }, {\n    key: \"setMapOptions\",\n    value: function setMapOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var markers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var labels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var clusters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.mapOptions = objectAssign(this.defaultOptions, options);\n      this.markersOptions = markers;\n      this.labelsOptions = labels;\n      this.clustersOptions = clusters;\n    }\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      return this.points;\n    }\n  }, {\n    key: \"getMarkers\",\n    value: function getMarkers() {\n      return this.markers;\n    }\n  }, {\n    key: \"getMarker\",\n    value: function getMarker(marker) {\n      if (typeof marker === 'string') {\n        marker = this.markers.find(function (m) {\n          return m.id === marker;\n        });\n      }\n\n      return marker;\n    }\n  }, {\n    key: \"getMarkerIcons\",\n    value: function getMarkerIcons() {\n      return this.icons;\n    }\n  }, {\n    key: \"getMarkerIconByType\",\n    value: function getMarkerIconByType(iconType) {\n      if (this.icons[iconType]) {\n        return this.icons[iconType];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getMarkerIconType\",\n    value: function getMarkerIconType(marker) {\n      marker = this.getMarker(marker);\n      return marker.iconType;\n    }\n  }, {\n    key: \"getGeolocation\",\n    value: function getGeolocation() {\n      return new Promise(function (resolve, reject) {\n        if (navigator.geolocation) {\n          navigator.geolocation.getCurrentPosition(resolve, reject, {\n            maximumAge: 60000,\n            timeout: 20000,\n            enableHighAccuracy: true\n          });\n        } else {\n          reject(new Error());\n        }\n      });\n    }\n  }, {\n    key: \"initMap\",\n    value: function initMap() {\n      console.error(\"\".concat(this.provider, \" has no 'initMap' method implemented.\"));\n    }\n  }, {\n    key: \"setPoint\",\n    value: function setPoint() {\n      console.error(\"\".concat(this.provider, \" has no 'setPoint' method implemented.\"));\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers() {\n      console.error(\"\".concat(this.provider, \" has no 'addMarkers' method implemented.\"));\n    }\n  }, {\n    key: \"addUserMarker\",\n    value: function addUserMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'addUserMarker' method implemented.\"));\n    }\n  }, {\n    key: \"addMarker\",\n    value: function addMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'addMarker' method implemented.\"));\n    }\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'removeMarker' method implemented.\"));\n    }\n  }, {\n    key: \"setMarkerIcons\",\n    value: function setMarkerIcons() {\n      console.error(\"\".concat(this.provider, \" has no 'setMarkerIcons' method implemented.\"));\n    }\n  }, {\n    key: \"setIconOnMarker\",\n    value: function setIconOnMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'setIconOnMarker' method implemented.\"));\n    }\n  }, {\n    key: \"focusOnMarker\",\n    value: function focusOnMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'focusOnMarker' method implemented.\"));\n    }\n  }, {\n    key: \"addCluster\",\n    value: function addCluster() {\n      console.error(\"\".concat(this.provider, \" has no 'addCluster' method implemented.\"));\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter() {\n      console.error(\"\".concat(this.provider, \" has no 'setCenter' method implemented.\"));\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds() {\n      console.error(\"\".concat(this.provider, \" has no 'fitBounds' method implemented.\"));\n    }\n  }, {\n    key: \"extendBounds\",\n    value: function extendBounds() {\n      console.error(\"\".concat(this.provider, \" has no 'extendBounds' method implemented.\"));\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      console.error(\"\".concat(this.provider, \" has no 'getBounds' method implemented.\"));\n    }\n  }, {\n    key: \"panTo\",\n    value: function panTo() {\n      console.error(\"\".concat(this.provider, \" has no 'panTo' method implemented.\"));\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom() {\n      console.error(\"\".concat(this.provider, \" has no 'setZoom' method implemented.\"));\n    }\n  }, {\n    key: \"listenZoomChange\",\n    value: function listenZoomChange() {\n      console.error(\"\".concat(this.provider, \" has no 'listenZoomChange' method implemented.\"));\n    }\n  }, {\n    key: \"minifyMarkerIcons\",\n    value: function minifyMarkerIcons() {\n      console.error(\"\".concat(this.provider, \" has no 'minifyMarkerIcons' method implemented.\"));\n    }\n  }]);\n\n  return AbstractMap;\n}();\n\nmodule.exports = AbstractMap;\n\n//# sourceURL=webpack:///./src/AbstractMap.js?");

/***/ }),

/***/ "./src/providers/gmaps-widget/GmapsWidget.js":
/*!***************************************************!*\
  !*** ./src/providers/gmaps-widget/GmapsWidget.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Google Map v3\n * API Documentation: https://developers.google.com/maps/documentation/javascript/\n * MarkerClusterer: https://gmaps-marker-clusterer.github.io/gmaps-marker-clusterer/\n */\n\n/*jshint -W079 */\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar AbstractMap = __webpack_require__(/*! ../../AbstractMap */ \"./src/AbstractMap.js\");\n/* jshint +W079 */\n\n\nvar domUtils = __webpack_require__(/*! ../../utils/dom */ \"./src/utils/dom.js\");\n\nvar loaderUtils = __webpack_require__(/*! ../../utils/loader */ \"./src/utils/loader.js\");\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar MarkerClusterer = __webpack_require__(/*! @google/markerclusterer */ \"./node_modules/@google/markerclusterer/src/markerclusterer.js\");\n\nvar GoogleMap =\n/*#__PURE__*/\nfunction (_AbstractMap) {\n  _inherits(GoogleMap, _AbstractMap);\n\n  function GoogleMap() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, GoogleMap);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(GoogleMap)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.provider = 'GoogleMap';\n    window.google = document.querySelector('[data-reactroot]').contentWindow.google;\n    return _this;\n  }\n\n  _createClass(GoogleMap, [{\n    key: \"load\",\n    value: function load(callback) {\n      this.domElement.classList.add('batmap__map', 'batmap-gmaps');\n\n      if (window.google && window.google.maps) {\n        setTimeout(callback, 0);\n        return;\n      }\n\n      callback = loaderUtils.addLoader(this.domElement, callback);\n      var iframe = document.querySelector('[data-reactroot]');\n      var resources = [];\n      var urlParams = '?v=3.37&language=' + this.locale + '&key=' + this.apiKey;\n      resources.push(domUtils.createScript('//maps.googleapis.com/maps/api/js' + urlParams));\n      domUtils.addResources(iframe.contentDocument.head, resources, callback);\n    }\n  }, {\n    key: \"setMapOptions\",\n    value: function setMapOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var markers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var labels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var clusters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.mapOptions = objectAssign({\n        center: {\n          lat: 0,\n          lng: 0\n        },\n        zoom: 12,\n        locationZoom: 16,\n        mapTypeControl: false,\n        zoomControl: true,\n        zoomControlOptions: {\n          position: google.maps.ControlPosition.TOP_LEFT\n        },\n        streetViewControl: false\n      }, options);\n      this.markersOptions = markers;\n      this.labelsOptions = labels;\n      this.clustersOptions = clusters;\n    }\n  }, {\n    key: \"initMap\",\n    value: function initMap() {\n      this.bounds = new google.maps.LatLngBounds();\n      this.map = new google.maps.Map(this.domElement, this.mapOptions);\n    }\n  }, {\n    key: \"setPoint\",\n    value: function setPoint(location, iconType) {\n      var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var point = {\n        position: new google.maps.LatLng(location.latitude, location.longitude),\n        id: \"\".concat(location._id),\n        location: location,\n        iconType: iconType\n      };\n\n      if (this.showLabel && label) {\n        point.label = {\n          text: \"\".concat(label)\n        };\n      }\n\n      this.points.push(point);\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers() {\n      var _this2 = this;\n\n      var eventCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      [].forEach.call(this.points, function (point) {\n        _this2.addMarker(point, eventCallback);\n      });\n\n      if (this.showCluster && this.icons.cluster && this.points.length > 1) {\n        this.addCluster();\n      }\n    }\n  }, {\n    key: \"addMarker\",\n    value: function addMarker(point) {\n      var eventCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var marker = new google.maps.Marker(point);\n      this.markers.push(marker);\n      marker.setMap(this.map);\n      this.setIconOnMarker(marker, point.iconType);\n      [].forEach.call(Object.keys(eventCallback), function (event) {\n        var callback = eventCallback[event];\n        marker.addListener(event, callback(marker));\n      });\n      this.extendBounds(marker.position);\n    }\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker(marker) {\n      marker = this.getMarker(marker);\n      marker.setMap(null);\n      this.markers = this.markers.filter(function (m) {\n        return m.id !== marker.id;\n      });\n    }\n  }, {\n    key: \"setMarkerIcons\",\n    value: function setMarkerIcons() {\n      var _this3 = this;\n\n      Object.keys(this.markersOptions).forEach(function (type) {\n        var options = _this3.markersOptions[type];\n        var iconAnchor = options.anchor || [options.width / 2, options.height];\n        var iconLabelOptions = options.label || {};\n        var labelOrigin = options.origin || _this3.labelsOptions.origin || [options.width / 2, options.height / 2];\n        _this3.icons[type] = {\n          url: options.url,\n          scaledSize: new google.maps.Size(options.width, options.height),\n          anchor: new google.maps.Point(iconAnchor[0], iconAnchor[1]),\n          labelOrigin: new google.maps.Point(labelOrigin[0], labelOrigin[1]),\n          labelOptions: _this3.getLabelOptions(iconLabelOptions)\n        };\n      });\n    }\n  }, {\n    key: \"getLabelOptions\",\n    value: function getLabelOptions(options) {\n      return {\n        color: options.color || this.labelsOptions.color,\n        font: options.font || this.labelsOptions.font,\n        size: options.size || this.labelsOptions.size,\n        weight: options.weight || this.labelsOptions.weight\n      };\n    }\n  }, {\n    key: \"setIconOnMarker\",\n    value: function setIconOnMarker(marker, iconType) {\n      var isLabeled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      marker = this.getMarker(marker);\n      var icon = this.icons[iconType];\n\n      if (marker && icon) {\n        marker.setIcon(icon);\n        marker.iconType = iconType;\n\n        if (this.showLabel && isLabeled) {\n          var iconLabelOptions = icon.labelOptions;\n          var label = {\n            color: iconLabelOptions.color,\n            fontFamily: iconLabelOptions.family,\n            fontSize: iconLabelOptions.size,\n            fontWeight: iconLabelOptions.weight,\n            text: marker.label.text\n          };\n          marker.setLabel(label);\n        }\n      }\n    }\n  }, {\n    key: \"focusOnMarker\",\n    value: function focusOnMarker(marker) {\n      marker = this.getMarker(marker);\n      this.map.setZoom(this.mapOptions.locationZoom);\n      this.panTo(marker.position);\n    }\n  }, {\n    key: \"addUserMarker\",\n    value: function addUserMarker(position, iconType) {\n      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (position) {\n        var point = {\n          id: \"\".concat(id),\n          map: this.map,\n          position: new google.maps.LatLng(position.latitude, position.longitude),\n          iconType: iconType\n        };\n        this.userMarker = new google.maps.Marker(point);\n        this.setIconOnMarker(this.userMarker, iconType, false);\n        this.extendBounds(this.userMarker.position);\n      }\n    }\n  }, {\n    key: \"addCluster\",\n    value: function addCluster() {\n      var icon = this.icons.cluster;\n      this.cluster = new MarkerClusterer(this.map, this.markers, objectAssign({\n        averageCenter: true,\n        styles: [{\n          url: icon.url,\n          width: icon.scaledSize.width,\n          height: icon.scaledSize.height,\n          iconAnchor: icon.anchor,\n          textSize: icon.labelOptions.size,\n          textColor: icon.labelOptions.color\n        }]\n      }, this.clustersOptions));\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(zoom) {\n      this.map.setZoom(zoom);\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter(position) {\n      this.map.setCenter(position);\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      return this.bounds;\n    }\n  }, {\n    key: \"extendBounds\",\n    value: function extendBounds(position) {\n      return this.bounds.extend(position);\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds(bounds) {\n      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.mapOptions.zoom;\n\n      if (this.markers.length > 1) {\n        this.map.fitBounds(bounds);\n      } else {\n        this.setCenter(this.markers[0].position);\n        this.setZoom(zoom);\n      }\n    }\n  }, {\n    key: \"panTo\",\n    value: function panTo(position) {\n      this.map.panTo(position);\n    }\n  }, {\n    key: \"listenZoomChange\",\n    value: function listenZoomChange(callback) {\n      var _this4 = this;\n\n      this.map.addListener('zoom_changed', function () {\n        return callback(_this4.map.getZoom());\n      });\n    }\n  }, {\n    key: \"minifyMarkerIcons\",\n    value: function minifyMarkerIcons(zoom) {\n      var _this5 = this;\n\n      var breakZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n      var minifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.8;\n\n      if (zoom < breakZoom + 1 && !this.isMinifiedMarkerIcons) {\n        [].forEach.call(Object.keys(this.icons), function (key) {\n          var size = _this5.icons[key].scaledSize;\n          _this5.icons[key].scaledSize.width = size.width * minifier;\n          _this5.icons[key].scaledSize.height = size.height * minifier;\n        });\n        this.isMinifiedMarkerIcons = true;\n      } else if (zoom > breakZoom && this.isMinifiedMarkerIcons) {\n        [].forEach.call(Object.keys(this.icons), function (key) {\n          var size = _this5.icons[key].scaledSize;\n          _this5.icons[key].scaledSize.width = size.width / minifier;\n          _this5.icons[key].scaledSize.height = size.height / minifier;\n        });\n        this.isMinifiedMarkerIcons = false;\n      }\n    }\n  }]);\n\n  return GoogleMap;\n}(AbstractMap);\n\nwindow.GoogleMap = GoogleMap;\nwindow.BatMap = GoogleMap;\ndocument.querySelector('[data-reactroot]').contentWindow.GoogleMap = GoogleMap;\ndocument.querySelector('[data-reactroot]').contentWindow.BatMap = GoogleMap;\n\n//# sourceURL=webpack:///./src/providers/gmaps-widget/GmapsWidget.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./src/style.css\");\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(/*! ../node_modules/style-loader/addStyles.js */ \"./node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./src/style.css?");

/***/ }),

/***/ "./src/utils/dom.js":
/*!**************************!*\
  !*** ./src/utils/dom.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar ieUtils = __webpack_require__(/*! ./ie */ \"./src/utils/ie.js\");\n\nvar isAString = __webpack_require__(/*! ./type */ \"./src/utils/type.js\").isAString;\n\nvar isDefined = __webpack_require__(/*! simple-js-validator */ \"./node_modules/simple-js-validator/lib/simple.js.validator.js\").isDefined;\n\nmodule.exports = {\n  addScript: function addScript(domElement, src) {\n    domElement.appendChild(this.createScript(src));\n  },\n  addStyle: function addStyle(domElement, href) {\n    domElement.appendChild(this.createStyle(href));\n  },\n  addResources: function addResources(domElement, resources, callback) {\n    var nbLoaded = 0;\n\n    if (resources.length === 0) {\n      callback();\n    }\n\n    resources.forEach(function (resource) {\n      ieUtils.addLoadListener(resource, function () {\n        nbLoaded++;\n\n        if (nbLoaded === resources.length) {\n          callback();\n        }\n      });\n      domElement.appendChild(resource);\n    });\n  },\n  createScript: function createScript(src) {\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = src;\n    script.async = true;\n    return script;\n  },\n  createStyle: function createStyle(href) {\n    var style = document.createElement('link');\n    style.rel = 'stylesheet';\n    style.href = href;\n    return style;\n  },\n  isHTMLElement: function isHTMLElement(obj) {\n    return obj && _typeof(obj) === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string';\n  },\n  extractTextAndCssClasses: function extractTextAndCssClasses(str) {\n    var div = document.createElement('div');\n    div.innerHTML = str;\n    var textContent = div.textContent || div.innerText || '';\n    var classes = '';\n\n    if (isDefined(div.firstChild)) {\n      classes = div.firstChild.className;\n    }\n\n    return {\n      textContent: textContent,\n      classes: classes\n    };\n  },\n  // use a memoized version of the function as il would be silly to repeat the operation\n  getStyleFromCss: memoize(function (cssClass) {\n    var div = document.createElement('div');\n    div.className = cssClass;\n    document.body.appendChild(div);\n    var style = window.getComputedStyle(div);\n    var result = {\n      top: extractPx(style.top),\n      left: extractPx(style.left)\n    };\n    document.body.removeChild(div);\n    return result;\n  })\n};\n\nfunction extractPx(str) {\n  if (true === isAString(str)) {\n    var pxValue = str.replace('px', '').replace('\"', '');\n    var pxNumber = parseInt(pxValue);\n    return isFinite(pxNumber) ? pxNumber : 0;\n  } else {\n    return 0;\n  }\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function (arg) {\n    if (arg in cache) {\n      return cache[arg];\n    } else {\n      try {\n        var result = func(arg);\n        cache[arg] = result;\n        return result;\n      } catch (e) {\n        console.log(e);\n        return null;\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./src/utils/dom.js?");

/***/ }),

/***/ "./src/utils/ie.js":
/*!*************************!*\
  !*** ./src/utils/ie.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  \"delete\": function _delete(obj, key) {\n    try {\n      delete obj[key];\n    } catch (e) {\n      obj[key] = undefined;\n    }\n  },\n  addEventListener: function addEventListener(domElement, event, callback, useCapture) {\n    if (domElement.addEventListener) {\n      domElement.addEventListener(event, callback, useCapture);\n    } else {\n      domElement.attachEvent('on' + event, callback);\n    }\n  },\n  addLoadListener: function addLoadListener(resource, callback) {\n    resource.onreadystatechange = function () {\n      if (this.readyState === 'complete') {\n        callback();\n      }\n    };\n\n    resource.onload = callback;\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/ie.js?");

/***/ }),

/***/ "./src/utils/loader.js":
/*!*****************************!*\
  !*** ./src/utils/loader.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaultLoaderClass = 'batmap__spinner';\nmodule.exports = {\n  addLoader: function addLoader(domElement, callback) {\n    var customClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var loader = document.createElement('div');\n\n    if (typeof customClass === 'string') {\n      loader.className = customClass;\n    } else {\n      loader.className = defaultLoaderClass;\n    }\n\n    domElement.appendChild(loader);\n    return function () {\n      domElement.removeChild(loader);\n      callback();\n    };\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/loader.js?");

/***/ }),

/***/ "./src/utils/type.js":
/*!***************************!*\
  !*** ./src/utils/type.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction isAString(something) {\n  return typeof something === 'string';\n}\n\nfunction isAFunction(something) {\n  return typeof something === 'function';\n}\n\nmodule.exports = {\n  isAString: isAString,\n  isAFunction: isAFunction\n};\n\n//# sourceURL=webpack:///./src/utils/type.js?");

/***/ })

/******/ });