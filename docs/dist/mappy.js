/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/providers/mappy/Mappy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/asap/browser-raw.js":
/*!******************************************!*\
  !*** ./node_modules/asap/browser-raw.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jsâ€™s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/asap/browser-raw.js?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/style.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/style.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\nexports.push([module.i, \"/* Loader */\\n@keyframes scaleout {\\n    0% {\\n        transform: scale(0.0);\\n    } 100% {\\n          transform: scale(1.0);\\n          opacity: 0;\\n      }\\n}\\n\\n.batmap__spinner {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    content: '';\\n    width: 50px;\\n    height: 50px;\\n    margin: auto;\\n    padding: 50px 0 0 50px;\\n    background-color: #333;\\n\\n    border-radius: 100%;\\n    animation: scaleout 1.0s infinite ease-in-out;\\n}\\n\\n.batmap__map {\\n    position: relative;\\n    z-index: 0;\\n}\\n\\n/* Mappy */\\n.batmap-mappy .mappy-control-zoom a span {\\n    position: relative;\\n    top: -5px;\\n}\\n\\n.batmap-mappy .leaflet-control.leaflet-control-attribution,\\n.batmap-mappy .leaflet-control.leaflet-control-scale {\\n    padding: 0 5px;\\n}\\n\\n/* Leaflet */\\n.batmap-leaflet.leaflet-touch .leaflet-bar a {\\n    line-height: 26px;\\n}\\n\", \"\"]);\n\n//# sourceURL=webpack:///./src/style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction ToObject(val) {\n\tif (val == null) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction ownEnumerableKeys(obj) {\n\tvar keys = Object.getOwnPropertyNames(obj);\n\n\tif (Object.getOwnPropertySymbols) {\n\t\tkeys = keys.concat(Object.getOwnPropertySymbols(obj));\n\t}\n\n\treturn keys.filter(function (key) {\n\t\treturn propIsEnumerable.call(obj, key);\n\t});\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar from;\n\tvar keys;\n\tvar to = ToObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = arguments[s];\n\t\tkeys = ownEnumerableKeys(Object(from));\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tto[keys[i]] = from[keys[i]];\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/promise/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/promise/lib/core.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar asap = __webpack_require__(/*! asap/raw */ \"./node_modules/asap/browser-raw.js\");\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('Promise constructor\\'s argument is not a function');\n  }\n  this._U = 0;\n  this._V = 0;\n  this._W = null;\n  this._X = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._Y = null;\nPromise._Z = null;\nPromise._0 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n}\nfunction handle(self, deferred) {\n  while (self._V === 3) {\n    self = self._W;\n  }\n  if (Promise._Y) {\n    Promise._Y(self);\n  }\n  if (self._V === 0) {\n    if (self._U === 0) {\n      self._U = 1;\n      self._X = deferred;\n      return;\n    }\n    if (self._U === 1) {\n      self._U = 2;\n      self._X = [self._X, deferred];\n      return;\n    }\n    self._X.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._V === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._V === 1) {\n        resolve(deferred.promise, self._W);\n      } else {\n        reject(deferred.promise, self._W);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._W);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._V = 3;\n      self._W = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._V = 1;\n  self._W = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._V = 2;\n  self._W = newValue;\n  if (Promise._Z) {\n    Promise._Z(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._U === 1) {\n    handle(self, self._X);\n    self._X = null;\n  }\n  if (self._U === 2) {\n    for (var i = 0; i < self._X.length; i++) {\n      handle(self, self._X[i]);\n    }\n    self._X = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  });\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/core.js?");

/***/ }),

/***/ "./node_modules/promise/lib/es6-extensions.js":
/*!****************************************************!*\
  !*** ./node_modules/promise/lib/es6-extensions.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._0);\n  p._V = 1;\n  p._W = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nvar iterableToArray = function (iterable) {\n  if (typeof Array.from === 'function') {\n    // ES2015+, iterables exist\n    iterableToArray = Array.from;\n    return Array.from(iterable);\n  }\n\n  // ES5, only arrays and array-likes exist\n  iterableToArray = function (x) { return Array.prototype.slice.call(x); };\n  return Array.prototype.slice.call(iterable);\n}\n\nPromise.all = function (arr) {\n  var args = iterableToArray(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._V === 3) {\n            val = val._W;\n          }\n          if (val._V === 1) return res(i, val._W);\n          if (val._V === 2) reject(val._W);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    iterableToArray(values).forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/es6-extensions.js?");

/***/ }),

/***/ "./node_modules/promise/lib/rejection-tracking.js":
/*!********************************************************!*\
  !*** ./node_modules/promise/lib/rejection-tracking.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Promise = __webpack_require__(/*! ./core */ \"./node_modules/promise/lib/core.js\");\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._Y = null;\n  Promise._Z = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._Y = function (promise) {\n    if (\n      promise._V === 2 && // IS REJECTED\n      rejections[promise._1]\n    ) {\n      if (rejections[promise._1].logged) {\n        onHandled(promise._1);\n      } else {\n        clearTimeout(rejections[promise._1].timeout);\n      }\n      delete rejections[promise._1];\n    }\n  };\n  Promise._Z = function (promise, err) {\n    if (promise._U === 0) { // not yet handled\n      promise._1 = id++;\n      rejections[promise._1] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._1),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/promise/lib/rejection-tracking.js?");

/***/ }),

/***/ "./node_modules/simple-js-validator/lib/simple.js.validator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/simple-js-validator/lib/simple.js.validator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * Simple.Js.Validator v0.12.3\r\n *\r\n * @class Validator\r\n * A collection of simple validations for common actions\r\n *\r\n * @type {SimpleJS.Validator}\r\n */\r\n\r\n(function(exports) {\r\n  \"use strict\";\r\n\r\n  /**\r\n   * Returns ***true*** if the value is empty; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if empty; false if not empty\r\n   */\r\n  var isEmpty = exports.isEmpty = function(value) {\r\n\r\n    if (typeof value === 'undefined') {\r\n      return true;\r\n    } else if (value === null) {\r\n      return true;\r\n    } else if (isNAN(value)) {\r\n      return true;\r\n    } else if (value === '') {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return false;\r\n    } else if (value === false) {\r\n      return false;\r\n    } else if (isDate(value)) {\r\n      // new Date() is an object, but it has no keys/props so it will fail the isObject check\r\n      // so if it is a date, it is considered populated\r\n      // also the for loop with the hasOwnProperty did not pass the new Date() either\r\n      // also the _.isEmpty did not pass the new Date() check\r\n      // ...could use _.isDate, but trying to reduce the dependency on external libs\r\n      return false;\r\n    } else if (isError(value)) {\r\n      // new Error() is an object, but it has no keys/props so it will fail the isObject\r\n      // so if it is an error, it is considered populated\r\n      return false;\r\n    } else if (isEmptyObject(value)) {\r\n      // this did not pass the new Date() check by itself, so added the date check above\r\n      // this did not pass the new Error() check by itself, so added the error check above\r\n      return true;\r\n    } else if (isEmptyArray(value)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is not empty; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if not empty; false if empty\r\n   */\r\n  var isNotEmpty = exports.isNotEmpty = function(value) {\r\n    return !isEmpty(value);\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is defined; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isDefined = exports.isDefined = function(value) {\r\n\r\n    if (typeof value === 'undefined') {\r\n      return false;\r\n    } else if (value === null) {\r\n      return false;\r\n    } else if (isNAN(value)) {\r\n      return false;\r\n    } else if (value === '') {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return true;\r\n    } else if (value === false) {\r\n      return true;\r\n    } else if (isObject(value)) {\r\n      return true;\r\n    } else if (isArray(value)) {\r\n      return true;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is not defined; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if not defined; false if defined\r\n   */\r\n  var isNotDefined = exports.isNotDefined = function(value) {\r\n    return !isDefined(value);\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is true, \"true\", \"T\", or 1; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - 0\r\n   *  - false\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - anything else\r\n   *\r\n   * Returns ***true*** for the following:\r\n   *\r\n   *  - true\r\n   *  - \"true\"\r\n   *  - \"T\"\r\n   *  - 1\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isTrue = exports.isTrue = function(value) {\r\n    if (value === true) {\r\n      return true;\r\n    } else if (value === 1) {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" && value.toLowerCase() === \"true\") {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"t\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns ***true*** if the value is false, \"false\", \"f\", or 0; otherwise, returns ***false***.\r\n   *\r\n   * Returns ***false*** for the following:\r\n   *\r\n   *  - typeof undefined\r\n   *  - null\r\n   *  - NaN\r\n   *  - '' (empty string)\r\n   *  - {} (empty object)\r\n   *  - [] (empty array)\r\n   *  - true\r\n   *  - 1\r\n   *  - anything else\r\n   *\r\n   *  * Returns ***true*** for the following:\r\n   *\r\n   *  - false\r\n   *  - \"false\"\r\n   *  - \"F\"\r\n   *  - 0\r\n   *\r\n   * @param {Object} value         value to check\r\n   * @returns {boolean}   true if defined; false if not defined\r\n   */\r\n  var isFalse = exports.isFalse = function(value) {\r\n    if (value === false) {\r\n      return true;\r\n    } else if (value === 0) {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"false\") {\r\n      return true;\r\n    } else if (value && typeof value === \"string\" &&  value.toLowerCase() === \"f\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Throws an error if the object is not defined (see {@link #isNotDefined} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsDefined = exports.assertIsDefined = function(toAssertName, toAssertObj){\r\n    if (isNotDefined(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is not defined.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is defined (see {@link #isDefined} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsNotDefined = exports.assertIsNotDefined = function(toAssertName, toAssertObj){\r\n    if (isDefined(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is defined.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is empty (see {@link #isEmpty} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsNotEmpty = exports.assertIsNotEmpty = function(toAssertName, toAssertObj){\r\n    if (isEmpty(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is empty.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Throws an error if the object is not empty (see {@link #isNotEmpty} method for definition).\r\n   *\r\n   * @param {String} toAssertName      The name associated with the object.  This name is used when the error is thrown.\r\n   * @param {Object} toAssertObj       The object to assert against\r\n   * @returns {void}\r\n   */\r\n  var assertIsEmpty = exports.assertIsEmpty = function(toAssertName, toAssertObj){\r\n    if (isNotEmpty(toAssertObj)) {\r\n      throw new Error(toAssertName + ' is not empty.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will throw an error if any input is not defined\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefined = exports.validateFunctionInputsAreDefined = function (fnInputs, inputsToValidate, functionName) {\r\n    return validateInputsAreDefined(fnInputs, inputsToValidate, 'fnInputs', functionName);\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will throw an error if any input is not defined\r\n   *\r\n   * @param {Object} inputs                       object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must be defined in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefined = exports.validateInputsAreDefined = function (inputs, inputsToValidate, inputName, functionName) {\r\n    functionName = functionName + ' validateInputsAreDefined ';\r\n\r\n    if (isEmpty(inputs)) {\r\n      throw new Error(functionName +  inputName + ' must not be empty');\r\n    }\r\n\r\n    if (!isArray(inputsToValidate)) {\r\n      throw new Error(functionName + 'inputsToValidate must be an array');\r\n    }\r\n\r\n    for (var i=0; i<inputsToValidate.length; i++) {\r\n      var input = inputsToValidate[i];\r\n\r\n      var toTest = getPropertyByString(inputs, input);\r\n\r\n      if (isNotDefined(toTest)) {\r\n        throw new Error(functionName + 'following input must be defined: ' + inputName + '.' + input);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefinedAsync = exports.validateFunctionInputsAreDefinedAsync = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreDefined(fnInputs, inputsToValidate, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are defined.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreDefinedCallbackOnError = exports.validateFunctionInputsAreDefinedCallbackOnError = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreDefined(fnInputs, inputsToValidate, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefinedAsync = exports.validateInputsAreDefinedAsync = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreDefined(fnInputs, inputsToValidate, inputName, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are defined.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate       a string array of the input names that must be defined in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreDefinedCallbackOnError = exports.validateInputsAreDefinedCallbackOnError = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreDefined(fnInputs, inputsToValidate, inputName, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will throw an error if any input is empty\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmpty = exports.validateFunctionInputsAreNotEmpty = function (fnInputs, inputsToValidate, functionName) {\r\n    return validateInputsAreNotEmpty(fnInputs, inputsToValidate, 'fnInputs', functionName);\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will throw an error if any input is empty\r\n   *\r\n   * @param {Object} inputs                       object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmpty = exports.validateInputsAreNotEmpty = function (inputs, inputsToValidate, inputName, functionName) {\r\n    functionName = functionName + ' validateInputsAreNotEmpty ';\r\n\r\n    if (isEmpty(inputs)) {\r\n      throw new Error(functionName +  inputName + ' must not be empty');\r\n    }\r\n\r\n    if (!isArray(inputsToValidate)) {\r\n      throw new Error(functionName + 'inputsToValidate must be an array');\r\n    }\r\n\r\n    for (var i=0; i<inputsToValidate.length; i++) {\r\n      var input = inputsToValidate[i];\r\n\r\n      var toTest = getPropertyByString(inputs, input);\r\n\r\n      if (isEmpty(toTest)) {\r\n        throw new Error(functionName + 'following input must not be empty: ' + inputName + '.' + input);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate      a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmptyAsync = exports.validateFunctionInputsAreNotEmptyAsync = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreNotEmpty(fnInputs, inputsToValidate, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all function inputs are not empty.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the function inputs\r\n   * @param {Array} inputsToValidate      a string array of the input names that must not be empty in the fnInputs\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateFunctionInputsAreNotEmptyCallbackOnError = exports.validateFunctionInputsAreNotEmptyCallbackOnError = function (fnInputs, inputsToValidate, functionName, callback) {\r\n\r\n    try {\r\n      validateFunctionInputsAreNotEmpty(fnInputs, inputsToValidate, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will call the callback with an error or 'done' when finished\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmptyAsync = exports.validateInputsAreNotEmptyAsync = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreNotEmpty(fnInputs, inputsToValidate, inputName, functionName);\r\n      return callback(null, 'done');\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates all inputs are not empty.  It will call the callback only if there is an error.\r\n   *\r\n   * @param {Object} fnInputs                     object containing all the inputs\r\n   * @param {Array} inputsToValidate              a string array of the input names that must not be empty in the inputs\r\n   * @param {String} inputName                    string identifier of the inputs to output with any error messages\r\n   * @param {String} functionName                 string identifier of the calling function to output with any error messages\r\n   * @param {Function} callback                   a callback function\r\n   * @returns {void}\r\n   */\r\n  var validateInputsAreNotEmptyCallbackOnError = exports.validateInputsAreNotEmptyCallbackOnError = function (fnInputs, inputsToValidate, inputName, functionName, callback) {\r\n\r\n    try {\r\n      validateInputsAreNotEmpty(fnInputs, inputsToValidate, inputName, functionName);\r\n      return;\r\n    } catch (err) {\r\n      return callback(err, null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if array; otherwise, false\r\n   */\r\n  var isArray = exports.isArray = function(obj) {\r\n    if (obj && typeof obj === 'object' && typeof obj.length !== 'undefined' && obj.length >= 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not array; otherwise, false\r\n   */\r\n  var isNotArray = exports.isNotArray = function(obj) {\r\n    return !isArray(obj);\r\n  };\r\n\r\n\r\n  /**\r\n   * Determines if the object is an empty array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if empty array; otherwise, false\r\n   */\r\n  var isEmptyArray = exports.isEmptyArray = function(obj) {\r\n    if (isArray(obj) && typeof obj.length !== 'undefined' && obj.length === 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a populated array or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if populated array; otherwise, false\r\n   */\r\n  var isNotEmptyArray = exports.isNotEmptyArray = function(obj) {\r\n    if (isArray(obj) && typeof obj.length !== 'undefined' && obj.length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a NaN or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if NaN; otherwise, false\r\n   */\r\n  var isNAN = exports.isNAN = function(obj) {\r\n    // NaN value check\r\n    // ...and yes you need to check that it is a number before checking that it is NotANumber.  Who knew?\r\n    if (typeof obj === 'number' && isNaN(obj)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a Date or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Date; otherwise, false\r\n   */\r\n  var isDate = exports.isDate = function(obj) {\r\n    // new Date() is an object, but it has no keys/props so it will fail straight isObject check\r\n    // so if it is a date, it is considered populated\r\n    // also the for loop with the hasOwnProperty did not pass the new Date() either\r\n    // also the _.isEmpty did not pass the new Date() check\r\n    // ...could use _.isDate, but trying to reduce the dependency on external libs\r\n    if (typeof obj === 'object' && Object.prototype.toString.call(obj) === \"[object Date]\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not a Date or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Date; otherwise, false\r\n   */\r\n  var isNotDate = exports.isNotDate = function(obj) {\r\n    return !isDate(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an Error or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Error; otherwise, false\r\n   */\r\n  var isError = exports.isError = function(obj) {\r\n    // new Error() is an object, but it has no keys/props so it will fail straight isObject check\r\n    if (typeof obj === 'object' && Object.prototype.toString.call(obj) === \"[object Error]\") {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an Error or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Error; otherwise, false\r\n   */\r\n  var isNotError = exports.isNotError = function(obj) {\r\n    return !isError(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an Object or not.  Note returns false on new Date() and new Error().\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if Object; otherwise, false\r\n   */\r\n  var isObject = exports.isObject = function(obj) {\r\n    // object check\r\n    // this returns false if obj=new Date()\r\n    // this returns false if obj=new Error()\r\n    if (obj && typeof obj === 'object' && isNotArray(obj) && isNotDate(obj) && isNotError(obj)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is not an Object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if not Object; otherwise, false\r\n   */\r\n  var isNotObject = exports.isNotObject = function(obj) {\r\n    return !isObject(obj);\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is an empty object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if empty object; otherwise, false\r\n   */\r\n  var isEmptyObject = exports.isEmptyObject = function(obj) {\r\n    if (isObject(obj) && Object.keys(obj).length === 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Determines if the object is a populated object or not\r\n   *\r\n   * @param {Object} obj                      object to be checked\r\n   * @returns {Boolean}                       true if populated object; otherwise, false\r\n   */\r\n  var isNotEmptyObject = exports.isNotEmptyObject = function(obj) {\r\n    if (isObject(obj) && Object.keys(obj).length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /*\r\n   * Gets the property based on the string.\r\n   * So if the obj={foo:{bar:{blah:\"here\"}}}, getPropertyByString(obj, \"foo.bar.blah\") would return \"here\"\r\n   * There cannot be any \".\" in any of the property names for this to work correctly\r\n   * see http://stackoverflow.com/questions/6906108/in-javascript-how-can-i-dynamically-get-a-nested-property-of-an-object\r\n   *\r\n   * @param {Object} obj                      object to be search\r\n   * @param {String} propString               name of the property to find; use \".\" to indicate parent/child elements\r\n   * @returns {Object}                        returns the property value\r\n   */\r\n  var getPropertyByString = exports.getPropertyByString = function(obj, propString) {\r\n    if (isEmpty(propString)) {return obj;}\r\n\r\n    var prop;\r\n    var props = propString.split('.');\r\n\r\n    var propLength = props.length - 1;\r\n    var i=0;\r\n    for (i=0; i < propLength; i++) {\r\n      prop = props[i];\r\n\r\n      if (typeof obj === 'object' && obj !== null && prop in obj) {\r\n        obj = obj[prop];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return obj[props[i]];\r\n  };\r\n\r\n  /*\r\n   * Sets the property based on the string.\r\n   * So if the obj={foo:{bar:{blah:\"here\"}}}, setPropertyByString(obj, \"foo.bar.blah\", \"newHere\") would replace \"here\" with \"newHere\"\r\n   * There cannot be any \".\" in any of the property names for this to work correctly\r\n   * see http://stackoverflow.com/questions/6906108/in-javascript-how-can-i-dynamically-get-a-nested-property-of-an-object\r\n   *\r\n   * @param {Object} obj                      object to be search\r\n   * @param {String} propString               name of the property to find; use \".\" to indicate parent/child elements\r\n   * @param {Object} newValue                 the property value to set\r\n   */\r\n  var setPropertyByString =  exports.setPropertyByString = function(obj, propString, newValue) {\r\n    if (isEmpty(propString)) {return obj;}\r\n\r\n    var prop;\r\n    var props = propString.split('.');\r\n\r\n    var propLength = props.length - 1;\r\n\r\n    if (propLength === 0) {\r\n      obj[propString] = newValue;\r\n    } else {\r\n      var lookupObj = obj;\r\n      for (var i=0; i <= propLength - 1; i++) {\r\n        prop = props[i];\r\n\r\n        if (typeof obj === 'object' && obj !== null && prop in obj) {\r\n          obj = obj[prop];\r\n        } else {\r\n          obj[prop] = {};\r\n          obj = obj[prop];\r\n        }\r\n      }\r\n\r\n      // then on last prop in propString\r\n      prop = props[i];\r\n      if (typeof obj === 'object' && obj !== null) {\r\n        obj[prop] = newValue;\r\n      } else {\r\n        // do not update anything since the obj doesn't exist\r\n      }\r\n    }\r\n    return;\r\n  };\r\n\r\n  var assertNestedListIsDefined =  exports.assertNestedListIsDefined = function(list) {\r\n    if (isNotArray(list)) {return false;}\r\n\r\n    list.forEach(function(item) {\r\n      assertNestedIsDefined.apply(null, item);\r\n    });\r\n\r\n    return true;\r\n  };\r\n\r\n  var assertNestedIsDefined =  exports.assertNestedIsDefined = function(obj, toAssertName) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    for (var i = 0; i < args.length; i++) {\r\n      if (!obj) {\r\n        throw new Error(toAssertName + ' is not defined.');\r\n      }\r\n      if (!obj.hasOwnProperty(args[i]) || isNotDefined(obj[args[i]])) {\r\n        throw new Error(toAssertName + '.' + args[i] + ' is not defined.');\r\n      }\r\n      obj = obj[args[i]];\r\n      toAssertName = toAssertName + '.' + args[i];\r\n    }\r\n    return true;\r\n  };\r\n\r\n})( false? undefined: exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/simple-js-validator/lib/simple.js.validator.js?");

/***/ }),

/***/ "./node_modules/style-loader/addStyles.js":
/*!************************************************!*\
  !*** ./node_modules/style-loader/addStyles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/addStyles.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/AbstractMap.js":
/*!****************************!*\
  !*** ./src/AbstractMap.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n__webpack_require__(/*! ./style.css */ \"./src/style.css\");\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar dom = __webpack_require__(/*! ./utils/dom */ \"./src/utils/dom.js\");\n\nif (typeof Promise === 'undefined') {\n  __webpack_require__(/*! promise/lib/rejection-tracking */ \"./node_modules/promise/lib/rejection-tracking.js\").enable();\n\n  window.Promise = __webpack_require__(/*! promise/lib/es6-extensions.js */ \"./node_modules/promise/lib/es6-extensions.js\");\n}\n\nvar AbstractMap = /*#__PURE__*/function () {\n  function AbstractMap(domSelector, apiKey, locale) {\n    var showCluster = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var showLabel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var showPosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    var callback = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function () {};\n\n    _classCallCheck(this, AbstractMap);\n\n    this.domElement = dom.isHTMLElement(domSelector) ? domSelector : document.querySelector(domSelector);\n    this.domId = this.domElement.id || '';\n    this.apiKey = apiKey;\n    this.locale = locale || 'en';\n    this.provider = '[No provider defined]';\n    this.showCluster = showCluster;\n    this.showLabel = showLabel;\n    this.showPosition = showPosition;\n    this.map = null;\n    this.points = [];\n    this.markers = [];\n    this.icons = [];\n    this.bounds = null;\n    this.cluster = null;\n    this.focusInProgress = false;\n    this.defaultOptions = {\n      zoom: 12,\n      locationZoom: 16\n    };\n    this.load(callback);\n  }\n\n  _createClass(AbstractMap, [{\n    key: \"load\",\n    value: function load(callback) {\n      callback();\n    }\n  }, {\n    key: \"setMapOptions\",\n    value: function setMapOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var markers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var labels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var clusters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.mapOptions = objectAssign(this.defaultOptions, options);\n      this.markersOptions = markers;\n      this.labelsOptions = labels;\n      this.clustersOptions = clusters;\n    }\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      return this.points;\n    }\n  }, {\n    key: \"getMarkers\",\n    value: function getMarkers() {\n      return this.markers;\n    }\n  }, {\n    key: \"getMarker\",\n    value: function getMarker(marker) {\n      if (typeof marker === 'string') {\n        marker = this.markers.find(function (m) {\n          return m.id === marker;\n        });\n      }\n\n      return marker;\n    }\n  }, {\n    key: \"getMarkerIcons\",\n    value: function getMarkerIcons() {\n      return this.icons;\n    }\n  }, {\n    key: \"getMarkerIconByType\",\n    value: function getMarkerIconByType(iconType) {\n      if (this.icons[iconType]) {\n        return this.icons[iconType];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getMarkerIconType\",\n    value: function getMarkerIconType(marker) {\n      marker = this.getMarker(marker);\n      return marker.iconType;\n    }\n  }, {\n    key: \"getGeolocation\",\n    value: function getGeolocation() {\n      return new Promise(function (resolve, reject) {\n        if (navigator.geolocation) {\n          navigator.geolocation.getCurrentPosition(resolve, reject, {\n            maximumAge: 60000,\n            timeout: 20000,\n            enableHighAccuracy: true\n          });\n        } else {\n          reject(new Error());\n        }\n      });\n    }\n  }, {\n    key: \"initMap\",\n    value: function initMap() {\n      console.error(\"\".concat(this.provider, \" has no 'initMap' method implemented.\"));\n    }\n  }, {\n    key: \"setPoint\",\n    value: function setPoint() {\n      console.error(\"\".concat(this.provider, \" has no 'setPoint' method implemented.\"));\n    }\n  }, {\n    key: \"clearPoints\",\n    value: function clearPoints() {\n      this.points.length = 0;\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers() {\n      console.error(\"\".concat(this.provider, \" has no 'addMarkers' method implemented.\"));\n    }\n  }, {\n    key: \"addUserMarker\",\n    value: function addUserMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'addUserMarker' method implemented.\"));\n    }\n  }, {\n    key: \"addMarker\",\n    value: function addMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'addMarker' method implemented.\"));\n    }\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'removeMarker' method implemented.\"));\n    }\n  }, {\n    key: \"removeCluster\",\n    value: function removeCluster() {\n      console.error(\"\".concat(this.provider, \" has no 'removeCluster' method implemented.\"));\n    }\n  }, {\n    key: \"removeAllMarkers\",\n    value: function removeAllMarkers() {\n      var _this = this;\n\n      if (this.cluster) {\n        this.removeCluster();\n      }\n\n      this.markers.forEach(function (marker) {\n        _this.removeMarker(marker);\n      });\n    }\n  }, {\n    key: \"setMarkerIcons\",\n    value: function setMarkerIcons() {\n      console.error(\"\".concat(this.provider, \" has no 'setMarkerIcons' method implemented.\"));\n    }\n  }, {\n    key: \"setIconOnMarker\",\n    value: function setIconOnMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'setIconOnMarker' method implemented.\"));\n    }\n  }, {\n    key: \"focusOnMarker\",\n    value: function focusOnMarker() {\n      console.error(\"\".concat(this.provider, \" has no 'focusOnMarker' method implemented.\"));\n    }\n  }, {\n    key: \"addCluster\",\n    value: function addCluster() {\n      console.error(\"\".concat(this.provider, \" has no 'addCluster' method implemented.\"));\n    }\n  }, {\n    key: \"makeLatLng\",\n    value: function makeLatLng() {\n      console.error(\"\".concat(this.provider, \" has no 'makeLatLng' method implemented.\"));\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter() {\n      console.error(\"\".concat(this.provider, \" has no 'setCenter' method implemented.\"));\n    }\n  }, {\n    key: \"getCenterLatLng\",\n    value: function getCenterLatLng() {\n      console.error(\"\".concat(this.provider, \" has no 'getCenterLatLng' method implemented.\"));\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds() {\n      console.error(\"\".concat(this.provider, \" has no 'fitBounds' method implemented.\"));\n    }\n  }, {\n    key: \"extendBounds\",\n    value: function extendBounds() {\n      console.error(\"\".concat(this.provider, \" has no 'extendBounds' method implemented.\"));\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      console.error(\"\".concat(this.provider, \" has no 'getBounds' method implemented.\"));\n    }\n  }, {\n    key: \"getBoundsLatLng\",\n    value: function getBoundsLatLng() {\n      console.error(\"\".concat(this.provider, \" has no 'getBoundsLatLng' method implemented.\"));\n    }\n  }, {\n    key: \"panTo\",\n    value: function panTo() {\n      console.error(\"\".concat(this.provider, \" has no 'panTo' method implemented.\"));\n    }\n  }, {\n    key: \"getZoom\",\n    value: function getZoom() {\n      console.error(\"\".concat(this.provider, \" has no 'getZoom' method implemented.\"));\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom() {\n      console.error(\"\".concat(this.provider, \" has no 'setZoom' method implemented.\"));\n    }\n  }, {\n    key: \"listenZoomChange\",\n    value: function listenZoomChange() {\n      console.error(\"\".concat(this.provider, \" has no 'listenZoomChange' method implemented.\"));\n    }\n  }, {\n    key: \"listenBoundsChange\",\n    value: function listenBoundsChange() {\n      console.error(\"\".concat(this.provider, \" has no 'listenBoundsChange' method implemented.\"));\n    }\n  }, {\n    key: \"minifyMarkerIcons\",\n    value: function minifyMarkerIcons() {\n      console.error(\"\".concat(this.provider, \" has no 'minifyMarkerIcons' method implemented.\"));\n    }\n  }]);\n\n  return AbstractMap;\n}();\n\nmodule.exports = AbstractMap;\n\n//# sourceURL=webpack:///./src/AbstractMap.js?");

/***/ }),

/***/ "./src/providers/mappy/Mappy.js":
/*!**************************************!*\
  !*** ./src/providers/mappy/Mappy.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Mappy Map\n * API Documentation: https://leafletjs.com/reference-1.0.3.html\n * MarkerCluster Documentation: https://leaflet.github.io/Leaflet.markercluster/\n */\n\n/*jshint -W079 */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar AbstractMap = __webpack_require__(/*! ../../AbstractMap */ \"./src/AbstractMap.js\");\n/* jshint +W079 */\n\n\nvar domUtils = __webpack_require__(/*! ../../utils/dom */ \"./src/utils/dom.js\");\n\nvar loaderUtils = __webpack_require__(/*! ../../utils/loader */ \"./src/utils/loader.js\");\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar L;\n\nvar Mappy = /*#__PURE__*/function (_AbstractMap) {\n  _inherits(Mappy, _AbstractMap);\n\n  var _super = _createSuper(Mappy);\n\n  function Mappy() {\n    var _this;\n\n    _classCallCheck(this, Mappy);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.provider = 'Mappy';\n    return _this;\n  }\n\n  _createClass(Mappy, [{\n    key: \"load\",\n    value: function load(callback) {\n      var _this2 = this;\n\n      this.domElement.classList.add('batmap__map', 'batmap-mappy');\n\n      if (window.L && window.L.Mappy) {\n        callback();\n        return;\n      }\n\n      callback = loaderUtils.addLoader(this.domElement, callback);\n      domUtils.addResources(document.head, [domUtils.createStyle('//cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css'), domUtils.createScript('//cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.js')], function () {\n        var resources = [domUtils.createScript('//d11lbkprc85eyb.cloudfront.net/Mappy/7.5.0/L.Mappy.js'), domUtils.createStyle('//d11lbkprc85eyb.cloudfront.net/Mappy/7.5.0/L.Mappy.css')];\n\n        if (_this2.showCluster) {\n          resources.push(domUtils.createScript('//d11lbkprc85eyb.cloudfront.net/plugins/mappy/7.5.0/leaflet.markercluster.js'));\n          resources.push(domUtils.createStyle('//d11lbkprc85eyb.cloudfront.net/plugins/mappy/7.5.0/MarkerCluster.Default.css'));\n          resources.push(domUtils.createStyle('//d11lbkprc85eyb.cloudfront.net/plugins/mappy/7.5.0/MarkerCluster.css'));\n        }\n\n        domUtils.addResources(document.head, resources, function () {\n          L = window.L;\n          L.Mappy.setImgPath('//d11lbkprc85eyb.cloudfront.net/Mappy/7.5.0/images/');\n          callback();\n        });\n      });\n    }\n  }, {\n    key: \"setMapOptions\",\n    value: function setMapOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var markers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var labels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var clusters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.mapOptions = objectAssign({\n        clientId: this.apiKey,\n        locale: this.locale,\n        center: [0, 0],\n        zoom: 12,\n        locationZoom: 16,\n        scrollwheel: true,\n        mapTypeControl: false,\n        panControl: false,\n        zoomControl: true,\n        scaleControl: false,\n        streetViewControl: false,\n        layersControl: {\n          publicTransport: false,\n          traffic: true,\n          viewMode: true,\n          trafficLegend: true\n        }\n      }, options);\n      this.markersOptions = markers;\n      this.labelsOptions = labels;\n      this.clustersOptions = clusters;\n    }\n  }, {\n    key: \"initMap\",\n    value: function initMap() {\n      this.bounds = new L.latLngBounds([]);\n      this.map = new L.Mappy.Map(this.domElement, this.mapOptions);\n    }\n  }, {\n    key: \"setPoint\",\n    value: function setPoint(location, iconType) {\n      var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var point = {\n        position: L.latLng(location.localisation.coordinates.latitude, location.localisation.coordinates.longitude),\n        id: \"\".concat(location._id),\n        location: location,\n        iconType: iconType\n      };\n\n      if (this.showLabel && label) {\n        point.label = \"\".concat(label);\n      }\n\n      this.points.push(point);\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers() {\n      var _this3 = this;\n\n      var eventCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.showCluster && this.icons.cluster) {\n        this.addCluster();\n      }\n\n      [].forEach.call(this.points, function (point) {\n        _this3.addMarker(point, eventCallback);\n      });\n    }\n  }, {\n    key: \"addMarker\",\n    value: function addMarker(point) {\n      var eventCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var marker = L.marker(point.position, point);\n      marker.id = point.id;\n      marker.location = point.location;\n      marker.options.alt = 'marker ' + point.location.name;\n\n      if (this.showCluster && this.icons.cluster) {\n        this.cluster.addLayer(marker);\n      } else {\n        marker.addTo(this.map);\n      }\n\n      [].forEach.call(Object.keys(eventCallback), function (event) {\n        var callback = eventCallback[event];\n        marker.on(event, callback(marker));\n      });\n      this.extendBounds(marker.getLatLng());\n      this.markers.push(marker);\n      this.setIconOnMarker(marker, point.iconType);\n    }\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker(marker) {\n      marker = this.getMarker(marker);\n      marker.removeFrom(this.map);\n      this.markers = this.markers.filter(function (m) {\n        return m.id !== marker.id;\n      });\n    }\n  }, {\n    key: \"removeCluster\",\n    value: function removeCluster() {\n      this.cluster.remove();\n    }\n  }, {\n    key: \"setMarkerIcons\",\n    value: function setMarkerIcons() {\n      var _this4 = this;\n\n      Object.keys(this.markersOptions).forEach(function (type) {\n        var options = _this4.markersOptions[type];\n        var iconAnchor = options.anchor || [options.width / 2, options.height];\n        var iconLabelOptions = options.label || {};\n        _this4.icons[type] = new L.Icon({\n          className: \"batmap-marker-\".concat(type),\n          iconUrl: options.url,\n          iconSize: [options.width, options.height],\n          iconAnchor: iconAnchor,\n          labelOptions: _this4.getLabelOptions(iconLabelOptions)\n        });\n      });\n    }\n  }, {\n    key: \"getLabelOptions\",\n    value: function getLabelOptions(options) {\n      return {\n        origin: options.origin || this.labelsOptions.origin || [options.width / 2, options.height / 2],\n        color: options.color || this.labelsOptions.color,\n        font: options.font || this.labelsOptions.font,\n        size: options.size || this.labelsOptions.size,\n        weight: options.weight || this.labelsOptions.weight\n      };\n    }\n  }, {\n    key: \"setIconOnMarker\",\n    value: function setIconOnMarker(marker, iconType) {\n      var isLabeled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      marker = this.getMarker(marker);\n      var icon = this.icons[iconType];\n\n      if (marker && icon) {\n        marker.iconType = iconType;\n\n        if (this.showLabel && isLabeled) {\n          var labelOptions = icon.options.labelOptions;\n          var span = document.createElement('span');\n          span.innerText = marker.options.label;\n          span.style.position = 'absolute';\n          span.style.top = \"\".concat(labelOptions.origin[0], \"px\");\n          span.style.left = \"\".concat(labelOptions.origin[1], \"px\");\n          span.style.transform = 'translate(-50%, -50%)';\n          span.style.color = \"\".concat(labelOptions.color);\n          span.style.fontFamily = \"\".concat(labelOptions.font);\n          span.style.fontWeight = \"\".concat(labelOptions.weight);\n          span.style.fontSize = \"\".concat(labelOptions.size, \"px\");\n          marker.setIcon(new L.DivIcon({\n            className: icon.options.className,\n            iconSize: icon.options.iconSize,\n            iconAnchor: icon.options.iconAnchor,\n            html: \"<img src=\\\"\".concat(icon.options.iconUrl, \"\\\" class=\\\"map-marker-\").concat(iconType, \"__image\\\" alt=\\\"\").concat(marker.options.alt, \"\\\">\").concat(span.outerHTML)\n          }));\n        } else {\n          marker.setIcon(icon);\n        }\n      }\n    }\n  }, {\n    key: \"focusOnMarker\",\n    value: function focusOnMarker(marker) {\n      var _this5 = this;\n\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        x: 0,\n        y: 0\n      };\n      this.focusInProgress = true;\n      var hasOffset = offset.x || offset.y;\n      marker = this.getMarker(marker);\n\n      var onMoveEnd = function onMoveEnd() {\n        if (hasOffset) {\n          hasOffset = false;\n\n          _this5.map.panBy(offset);\n        } else {\n          _this5.focusInProgress = false;\n\n          _this5.map.off('moveend', onMoveEnd, _this5);\n        }\n      };\n\n      this.map.on('moveend', onMoveEnd, this);\n      this.panTo(marker.getLatLng());\n    }\n  }, {\n    key: \"addUserMarker\",\n    value: function addUserMarker(position, iconType) {\n      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (position) {\n        // Backward compatibility\n        var latLng = position.latitude && position.longitude ? this.makeLatLng(position.latitude, position.longitude) : position;\n        this.userMarker = new L.marker(latLng);\n        this.userMarker.id = id;\n        this.userMarker.addTo(this.map);\n        this.setIconOnMarker(this.userMarker, iconType, false);\n        this.extendBounds(this.userMarker.getLatLng());\n      }\n    }\n  }, {\n    key: \"addCluster\",\n    value: function addCluster() {\n      var icon = this.icons.cluster;\n      this.cluster = L.markerClusterGroup(objectAssign({\n        showCoverageOnHover: false,\n        zoomToBoundsOnClick: true,\n        spiderfyOnMaxZoom: true,\n        iconCreateFunction: function iconCreateFunction(cluster) {\n          var labelOptions = icon.options.labelOptions;\n          var span = document.createElement('span');\n          span.innerText = cluster.getChildCount();\n          span.style.position = 'absolute';\n          span.style.top = \"\".concat(labelOptions.origin[0], \"px\");\n          span.style.left = \"\".concat(labelOptions.origin[1], \"px\");\n          span.style.transform = 'translate(-50%, -50%)';\n          span.style.color = \"\".concat(labelOptions.color);\n          span.style.fontFamily = \"\".concat(labelOptions.font);\n          span.style.fontWeight = \"\".concat(labelOptions.weight);\n          span.style.fontSize = \"\".concat(labelOptions.size, \"px\");\n          return L.divIcon({\n            className: icon.options.className,\n            html: \"<img src=\\\"\".concat(icon.options.iconUrl, \"\\\" class=\\\"map-marker-cluster__image\\\" alt=\\\"marker cluster (\").concat(cluster.getChildCount(), \")\\\">\") + span.outerHTML,\n            iconSize: icon.options.iconSize\n          });\n        }\n      }, this.clustersOptions));\n      this.map.addLayer(this.cluster);\n    }\n  }, {\n    key: \"getZoom\",\n    value: function getZoom() {\n      return this.map.getZoom();\n    }\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(zoom) {\n      this.map.setZoom(zoom);\n    }\n  }, {\n    key: \"makeLatLng\",\n    value: function makeLatLng(latitude, longitude) {\n      return L.latLng(latitude, longitude);\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter(position) {\n      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.mapOptions.zoom;\n      this.map.setView(position, zoom);\n    }\n  }, {\n    key: \"getCenterLatLng\",\n    value: function getCenterLatLng() {\n      return this.map.getCenter();\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      return this.bounds;\n    }\n  }, {\n    key: \"getBoundsLatLng\",\n    value: function getBoundsLatLng() {\n      var bounds = this.map.getBounds();\n      var northEast = bounds.getNorthEast();\n      var southWest = bounds.getSouthWest();\n      return [southWest.lat, southWest.lng, northEast.lat, northEast.lng];\n    }\n  }, {\n    key: \"extendBounds\",\n    value: function extendBounds(position) {\n      return this.bounds.extend(position);\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds(bounds) {\n      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.mapOptions.zoom;\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n      var options = {\n        maxZoom: zoom\n      };\n\n      if (!isNaN(padding)) {\n        options['padding'] = L.point(padding, padding);\n      } else {\n        options['paddingTopLeft'] = L.point(padding.left || 0, padding.top || 0);\n        options['paddingBottomRight'] = L.point(padding.right || 0, padding.bottom || 0);\n      }\n\n      this.map.fitBounds(bounds, options);\n    }\n  }, {\n    key: \"panTo\",\n    value: function panTo(position) {\n      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.mapOptions.locationZoom;\n      this.map.setView(position, zoom);\n    }\n  }, {\n    key: \"panBy\",\n    value: function panBy(x, y) {\n      this.map.panBy(L.point(x, y));\n    }\n  }, {\n    key: \"listenZoomChange\",\n    value: function listenZoomChange(callback) {\n      var _this6 = this;\n\n      this.map.on('zoomend', function () {\n        return callback(_this6.map.getZoom());\n      });\n    }\n  }, {\n    key: \"listenBoundsChange\",\n    value: function listenBoundsChange(callback) {\n      var _this7 = this;\n\n      var ignoreFocusOnMarker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.map.on('move', function () {\n        if (ignoreFocusOnMarker && _this7.focusInProgress) {\n          return;\n        }\n\n        return callback(_this7.getCenterLatLng());\n      });\n    }\n  }, {\n    key: \"minifyMarkerIcons\",\n    value: function minifyMarkerIcons(zoom) {\n      var _this8 = this;\n\n      var breakZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n      var minifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.8;\n\n      if (zoom < breakZoom + 1 && !this.isMinifiedMarkerIcons) {\n        [].forEach.call(Object.keys(this.icons), function (key) {\n          var size = _this8.icons[key].options.iconSize;\n          var width = size[0] * minifier;\n          var height = size[1] * minifier;\n          _this8.icons[key].options.iconSize = [width, height];\n          _this8.icons[key].options.iconAnchor = [width / 2, height];\n        });\n        this.refreshAllMarkers();\n        this.isMinifiedMarkerIcons = true;\n      } else if (zoom > breakZoom && this.isMinifiedMarkerIcons) {\n        [].forEach.call(Object.keys(this.icons), function (key) {\n          var size = _this8.icons[key].options.iconSize;\n          var width = size[0] / minifier;\n          var height = size[1] / minifier;\n          _this8.icons[key].options.iconSize = [width, height];\n          _this8.icons[key].options.iconAnchor = [width / 2, height];\n        });\n        this.refreshAllMarkers();\n        this.isMinifiedMarkerIcons = false;\n      }\n    }\n  }, {\n    key: \"refreshAllMarkers\",\n    value: function refreshAllMarkers() {\n      var _this9 = this;\n\n      this.getMarkers().forEach(function (marker) {\n        var iconName = _this9.getMarkerIconType(marker);\n\n        marker.setIcon(_this9.icons[iconName]);\n      });\n\n      if (this.userMarker) {\n        this.userMarker.setIcon(this.icons.user);\n      }\n    }\n  }]);\n\n  return Mappy;\n}(AbstractMap);\n\nwindow.MappyMap = Mappy;\nwindow.BatMap = Mappy;\n\n//# sourceURL=webpack:///./src/providers/mappy/Mappy.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./src/style.css\");\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(/*! ../node_modules/style-loader/addStyles.js */ \"./node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./src/style.css?");

/***/ }),

/***/ "./src/utils/dom.js":
/*!**************************!*\
  !*** ./src/utils/dom.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar ieUtils = __webpack_require__(/*! ./ie */ \"./src/utils/ie.js\");\n\nvar isAString = __webpack_require__(/*! ./type */ \"./src/utils/type.js\").isAString;\n\nvar isDefined = __webpack_require__(/*! simple-js-validator */ \"./node_modules/simple-js-validator/lib/simple.js.validator.js\").isDefined;\n\nmodule.exports = {\n  addScript: function addScript(domElement, src) {\n    domElement.appendChild(this.createScript(src));\n  },\n  addStyle: function addStyle(domElement, href) {\n    domElement.appendChild(this.createStyle(href));\n  },\n  addResources: function addResources(domElement, resources, callback) {\n    var nbLoaded = 0;\n\n    if (resources.length === 0) {\n      callback();\n    }\n\n    resources.forEach(function (resource) {\n      ieUtils.addLoadListener(resource, function () {\n        nbLoaded++;\n\n        if (nbLoaded === resources.length) {\n          callback();\n        }\n      });\n      domElement.appendChild(resource);\n    });\n  },\n  createScript: function createScript(src) {\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = src;\n    script.async = true;\n    return script;\n  },\n  createStyle: function createStyle(href) {\n    var style = document.createElement('link');\n    style.rel = 'stylesheet';\n    style.href = href;\n    return style;\n  },\n  isHTMLElement: function isHTMLElement(obj) {\n    return obj && _typeof(obj) === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string';\n  },\n  extractTextAndCssClasses: function extractTextAndCssClasses(str) {\n    var div = document.createElement('div');\n    div.innerHTML = str;\n    var textContent = div.textContent || div.innerText || '';\n    var classes = '';\n\n    if (isDefined(div.firstChild)) {\n      classes = div.firstChild.className;\n    }\n\n    return {\n      textContent: textContent,\n      classes: classes\n    };\n  },\n  // use a memoized version of the function as il would be silly to repeat the operation\n  getStyleFromCss: memoize(function (cssClass) {\n    var div = document.createElement('div');\n    div.className = cssClass;\n    document.body.appendChild(div);\n    var style = window.getComputedStyle(div);\n    var result = {\n      top: extractPx(style.top),\n      left: extractPx(style.left)\n    };\n    document.body.removeChild(div);\n    return result;\n  })\n};\n\nfunction extractPx(str) {\n  if (true === isAString(str)) {\n    var pxValue = str.replace('px', '').replace('\"', '');\n    var pxNumber = parseInt(pxValue);\n    return isFinite(pxNumber) ? pxNumber : 0;\n  } else {\n    return 0;\n  }\n}\n\nfunction memoize(func) {\n  var cache = {};\n  return function (arg) {\n    if (arg in cache) {\n      return cache[arg];\n    } else {\n      try {\n        var result = func(arg);\n        cache[arg] = result;\n        return result;\n      } catch (e) {\n        console.log(e);\n        return null;\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./src/utils/dom.js?");

/***/ }),

/***/ "./src/utils/ie.js":
/*!*************************!*\
  !*** ./src/utils/ie.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  \"delete\": function _delete(obj, key) {\n    try {\n      delete obj[key];\n    } catch (e) {\n      obj[key] = undefined;\n    }\n  },\n  addEventListener: function addEventListener(domElement, event, callback, useCapture) {\n    if (domElement.addEventListener) {\n      domElement.addEventListener(event, callback, useCapture);\n    } else {\n      domElement.attachEvent('on' + event, callback);\n    }\n  },\n  addLoadListener: function addLoadListener(resource, callback) {\n    resource.onreadystatechange = function () {\n      if (this.readyState === 'complete') {\n        callback();\n      }\n    };\n\n    resource.onload = callback;\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/ie.js?");

/***/ }),

/***/ "./src/utils/loader.js":
/*!*****************************!*\
  !*** ./src/utils/loader.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaultLoaderClass = 'batmap__spinner';\nmodule.exports = {\n  addLoader: function addLoader(domElement, callback) {\n    var customClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var loader = document.createElement('div');\n\n    if (typeof customClass === 'string') {\n      loader.className = customClass;\n    } else {\n      loader.className = defaultLoaderClass;\n    }\n\n    domElement.appendChild(loader);\n    return function () {\n      domElement.removeChild(loader);\n      callback();\n    };\n  }\n};\n\n//# sourceURL=webpack:///./src/utils/loader.js?");

/***/ }),

/***/ "./src/utils/type.js":
/*!***************************!*\
  !*** ./src/utils/type.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction isAString(something) {\n  return typeof something === 'string';\n}\n\nfunction isAFunction(something) {\n  return typeof something === 'function';\n}\n\nmodule.exports = {\n  isAString: isAString,\n  isAFunction: isAFunction\n};\n\n//# sourceURL=webpack:///./src/utils/type.js?");

/***/ })

/******/ });